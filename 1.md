# 二手车交易价格预测

# 一、赛题理解

## 1、赛题概况

比赛要求参赛选手根据给定的数据集，建立模型，二手汽车的交易价格。

赛题以预测二手车的交易价格为任务，数据集报名后可见并可下载，该数据来自某交易平台的二手车交易记录，总数据量超过40w，包含31列变量信息，其中15列为匿名变量。为了保证比赛的公平性，将会从中抽取15万条作为训练集，5万条作为测试集A，5万条作为测试集B，同时会对name、model、brand和regionCode等信息进行脱敏。

通过这道赛题来引导大家走进 AI 数据竞赛的世界，主要针对于于竞赛新人进行自我练 习、自我提高。

> 

## 2、数据概况

般而言，对于数据在比赛界面都有对应的数据概况介绍（匿名特征除外），说明列的性质特征。了解列的性质会有助于我们对于数据的理解和后续分析。 Tip:匿名特征，就是未告知数据列所属的性质的特征列。

~~~vue
train.csv

name - 汽车编码
regDate - 汽车注册时间
model - 车型编码
brand - 品牌
bodyType - 车身类型
fuelType - 燃油类型
gearbox - 变速箱
power - 汽车功率
kilometer - 汽车行驶公里
notRepairedDamage - 汽车有尚未修复的损坏
regionCode - 看车地区编码
seller - 销售方
offerType - 报价类型
creatDate - 广告发布时间
price - 汽车价格
v_0', 'v_1', 'v_2', 'v_3', 'v_4', 'v_5', 'v_6', 'v_7', 'v_8', 'v_9', 'v_10', 'v_11', 'v_12', 'v_13','v_14'（根据汽车的评论、标签等大量信息得到的embedding向量）【人工构造 匿名特征】
数字全都脱敏处理，都为label encoding形式，即数字形式
~~~

## 3.预测指标

评价标准为平均绝对误差MAE(Mean Absolute Error)。![1621397789843](C:\Users\Ccy\AppData\Roaming\Typora\typora-user-images\1621397789843.png)MAE越小，说明模型预测得越准确。

## 4.导入工具箱

~~~
## 基础工具
import numpy as np
import pandas as pd
import warnings
import matplotlib
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.special import jn
from IPython.display import display, clear_output
import time
import missingno as msno
import scipy.stats as st
warnings.filterwarnings('ignore')
%matplotlib inline

## 模型预测的
from sklearn import linear_model
from sklearn import preprocessing
from sklearn.svm import SVR
from sklearn.ensemble import RandomForestRegressor,GradientBoostingRegressor

## 数据降维处理的
from sklearn.decomposition import PCA,FastICA,FactorAnalysis,SparsePCA

import lightgbm as lgb
import xgboost as xgb

## 参数搜索和评价的
from sklearn.model_selection import GridSearchCV,cross_val_score,StratifiedKFold,train_test_split
from sklearn.metrics import mean_squared_error, mean_absolute_error
~~~

## 5.数据读取pandas

```python
## 通过Pandas对于数据进行读取 (pandas是一个很友好的数据读取函数库)
Train_data = pd.read_csv('used_car_train_20200313.csv', sep=' ')
Test_data = pd.read_csv('used_car_testB_20200421.csv', sep=' ')

## 输出数据的大小信息
print('Train data shape:',Train_data.shape)
print('Test data shape:',Test_data.shape)
```

实现效果：

![1621398097948](C:\Users\Ccy\AppData\Roaming\Typora\typora-user-images\1621398097948.png)



## 6.数据浏览

```
## 通过.head() 简要浏览读取数据的形式
Train_data.head()
```

![1621398207916](C:\Users\Ccy\AppData\Roaming\Typora\typora-user-images\1621398207916.png)

# 二、数据分析

## 1.总览数据概况

```
## 通过 .info() 简要可以看到对应一些数据列名，以及NAN缺失信息
Train_data.info()
```

## ![1621398266642](C:\Users\Ccy\AppData\Roaming\Typora\typora-user-images\1621398266642.png)

```
# 通过 .describe() 可以查看数值特征列的一些统计信息
Train_data.describe()
```

![1621398348630](C:\Users\Ccy\AppData\Roaming\Typora\typora-user-images\1621398348630.png)

## 2.判断数据缺失和异常

```
Train_data.isnull().sum()
```

![1621398399238](C:\Users\Ccy\AppData\Roaming\Typora\typora-user-images\1621398399238.png)

```
# nan可视化
missing = Train_data.isnull().sum()
missing = missing[missing > 0]
missing.sort_values(inplace=True)
missing.plot.bar()
```

![1621398459563](C:\Users\Ccy\AppData\Roaming\Typora\typora-user-images\1621398459563.png)

```
# 可视化看下缺省值
msno.matrix(Train_data.sample(250))
```

![1621398497837](C:\Users\Ccy\AppData\Roaming\Typora\typora-user-images\1621398497837.png)

```
msno.bar(Train_data.sample(1000))
```

![1621398533765](C:\Users\Ccy\AppData\Roaming\Typora\typora-user-images\1621398533765.png)

## 3.了解预测值的分布

```
查看skewness and kurtosis
sns.distplot(Train_data['price']);
print("Skewness: %f" % Train_data['price'].skew())
print("Kurtosis: %f" % Train_data['price'].kurt())
```

![1621399010813](C:\Users\Ccy\AppData\Roaming\Typora\typora-user-images\1621399010813.png)

```
## 绘制标签的统计图，查看标签分布
plt.hist(Y_data)
plt.show()
plt.close()
```

![1621399081315](C:\Users\Ccy\AppData\Roaming\Typora\typora-user-images\1621399081315.png)

## 4.数字特征分析

```
 相关性分析
price_numeric = Train_data[numeric_features]
correlation = price_numeric.corr()
print(correlation['price'].sort_values(ascending = False),'\n')
```

![1621399197928](C:\Users\Ccy\AppData\Roaming\Typora\typora-user-images\1621399197928.png)

```
f , ax = plt.subplots(figsize = (7, 7))

plt.title('Correlation of Numeric Features with Price',y=1,size=16)

sns.heatmap(correlation,square = True,  vmax=0.8)
```

![1621399243682](C:\Users\Ccy\AppData\Roaming\Typora\typora-user-images\1621399243682.png)

```
查看几个特征得 偏度和峰值
for col in numeric_features:
    print('{:15}'.format(col), 
          'Skewness: {:05.2f}'.format(Train_data[col].skew()) , 
          '   ' ,
          'Kurtosis: {:06.2f}'.format(Train_data[col].kurt())  
         )
```

![1621399281181](C:\Users\Ccy\AppData\Roaming\Typora\typora-user-images\1621399281181.png)

```
数字特征相互之间的关系可视化
sns.set()
columns = ['price', 'v_12', 'v_8' , 'v_0', 'power', 'v_5',  'v_2', 'v_6', 'v_1', 'v_14']
sns.pairplot(Train_data[columns],size = 2 ,kind ='scatter',diag_kind='kde')
plt.show()
```

![1621399327010](C:\Users\Ccy\AppData\Roaming\Typora\typora-user-images\1621399327010.png)

## 三、特征工程

## 1.删除异常值

```
# 这里我包装了一个异常值处理的代码，可以随便调用。
def outliers_proc(data, col_name, scale=3):
    """
    用于清洗异常值，默认用 box_plot（scale=3）进行清洗
    :param data: 接收 pandas 数据格式
    :param col_name: pandas 列名
    :param scale: 尺度
    :return:
    """

    def box_plot_outliers(data_ser, box_scale):
        """
        利用箱线图去除异常值
        :param data_ser: 接收 pandas.Series 数据格式
        :param box_scale: 箱线图尺度，
        :return:
        """
        iqr = box_scale * (data_ser.quantile(0.75) - data_ser.quantile(0.25))
        val_low = data_ser.quantile(0.25) - iqr
        val_up = data_ser.quantile(0.75) + iqr
        rule_low = (data_ser < val_low)
        rule_up = (data_ser > val_up)
        return (rule_low, rule_up), (val_low, val_up)

    data_n = data.copy()
    data_series = data_n[col_name]
    rule, value = box_plot_outliers(data_series, box_scale=scale)
    index = np.arange(data_series.shape[0])[rule[0] | rule[1]]
    print("Delete number is: {}".format(len(index)))
    data_n = data_n.drop(index)
    data_n.reset_index(drop=True, inplace=True)
    print("Now column number is: {}".format(data_n.shape[0]))
    index_low = np.arange(data_series.shape[0])[rule[0]]
    outliers = data_series.iloc[index_low]
    print("Description of data less than the lower bound is:")
    print(pd.Series(outliers).describe())
    index_up = np.arange(data_series.shape[0])[rule[1]]
    outliers = data_series.iloc[index_up]
    print("Description of data larger than the upper bound is:")
    print(pd.Series(outliers).describe())
    
    fig, ax = plt.subplots(1, 2, figsize=(10, 7))
    sns.boxplot(y=data[col_name], data=data, palette="Set1", ax=ax[0])
    sns.boxplot(y=data_n[col_name], data=data_n, palette="Set1", ax=ax[1])
    return data_n
    
Train_data = outliers_proc(Train_data, 'power', scale=3)
```

![1621399571749](C:\Users\Ccy\AppData\Roaming\Typora\typora-user-images\1621399571749.png)

2.特征构造

```
## 选择特征列
feature_cols = [col for col in numerical_cols if col not in ['price','brand','model']]
feature_cols = [col for col in feature_cols if 'Type' not in col]

## 提前特征列，标签列构造训练样本和测试样本
X_data = Train_data[feature_cols]
Y_data = Train_data['price']

X_test  = Test_data[feature_cols]

print('X train shape:',X_data.shape)
print('X test shape:',X_test.shape)
```

![1621399674381](C:\Users\Ccy\AppData\Roaming\Typora\typora-user-images\1621399674381.png)

# 四、建模调参

## 1、五折交叉验证

```
## xgb-Model
xgr = xgb.XGBRegressor(n_estimators=120, learning_rate=0.1, gamma=0, subsample=0.8,\
        colsample_bytree=0.9, max_depth=7) #,objective ='reg:squarederror'

scores_train = []
scores = []

## 5折交叉验证方式
sk=StratifiedKFold(n_splits=5,shuffle=True,random_state=0)
for train_ind,val_ind in sk.split(X_data,Y_data):
    
    train_x=X_data.iloc[train_ind].values
    train_y=Y_data.iloc[train_ind]
    val_x=X_data.iloc[val_ind].values
    val_y=Y_data.iloc[val_ind]
    
    xgr.fit(train_x,train_y)
    pred_train_xgb=xgr.predict(train_x)
    pred_xgb=xgr.predict(val_x)
    
    score_train = mean_absolute_error(train_y,pred_train_xgb)
    scores_train.append(score_train)
    score = mean_absolute_error(val_y,pred_xgb)
    scores.append(score)

print('Train mae:',np.mean(score_train))
print('Val mae',np.mean(scores))
```

![1621399927096](C:\Users\Ccy\AppData\Roaming\Typora\typora-user-images\1621399927096.png)

## 2.xgb、lgb模型训练

```
def build_model_xgb(x_train,y_train):
    model = xgb.XGBRegressor(n_estimators=150, learning_rate=0.1, gamma=0, subsample=0.8,\
        colsample_bytree=0.9, max_depth=7) #, objective ='reg:squarederror'
    model.fit(x_train, y_train)
    return model

def build_model_lgb(x_train,y_train):
    estimator = lgb.LGBMRegressor(num_leaves=127,n_estimators = 150)
    param_grid = {
        'learning_rate': [0.01, 0.05, 0.1, 0.2],
    }
    gbm = GridSearchCV(estimator, param_grid)
    gbm.fit(x_train, y_train)
    return gbm
## Split data with val
x_train,x_val,y_train,y_val = train_test_split(X_data,Y_data,test_size=0.3)
```

```
print('Train lgb...')
model_lgb = build_model_lgb(x_train,y_train)
val_lgb = model_lgb.predict(x_val)
MAE_lgb = mean_absolute_error(y_val,val_lgb)
print('MAE of val with lgb:',MAE_lgb)

print('Predict lgb...')
model_lgb_pre = build_model_lgb(X_data,Y_data)
subA_lgb = model_lgb_pre.predict(X_test)
print('Sta of Predict lgb:')
Sta_inf(subA_lgb)
```

![1621400042780](C:\Users\Ccy\AppData\Roaming\Typora\typora-user-images\1621400042780.png)

```
print('Train xgb...')
model_xgb = build_model_xgb(x_train,y_train)
val_xgb = model_xgb.predict(x_val)
MAE_xgb = mean_absolute_error(y_val,val_xgb)
print('MAE of val with xgb:',MAE_xgb)

print('Predict xgb...')
model_xgb_pre = build_model_xgb(X_data,Y_data)
subA_xgb = model_xgb_pre.predict(X_test)
print('Sta of Predict xgb:')
Sta_inf(subA_xgb)
```

![1621400078290](C:\Users\Ccy\AppData\Roaming\Typora\typora-user-images\1621400078290.png)

## 3.加权融合

~~~vue
## 这里我们采取了简单的加权融合的方式
val_Weighted = (1-MAE_lgb/(MAE_xgb+MAE_lgb))*val_lgb+(1-MAE_xgb/(MAE_xgb+MAE_lgb))*val_xgb
val_Weighted[val_Weighted<0]=10 # 由于我们发现预测的最小值有负数，而真实情况下，price为负是不存在的，由此我们进行对应的后修正
print('MAE of val with Weighted ensemble:',mean_absolute_error(y_val,val_Weighted))
~~~

![1621400171564](C:\Users\Ccy\AppData\Roaming\Typora\typora-user-images\1621400171564.png)

```
sub_Weighted = (1-MAE_lgb/(MAE_xgb+MAE_lgb))*subA_lgb+(1-MAE_xgb/(MAE_xgb+MAE_lgb))*subA_xgb

## 查看预测值的统计进行
plt.hist(Y_data)
plt.show()
plt.close()
```

![1621400220657](C:\Users\Ccy\AppData\Roaming\Typora\typora-user-images\1621400220657.png)

## 	4.结果导出

```
sub = pd.DataFrame()
sub['SaleID'] = X_test.SaleID
sub['price'] = sub_Weighted
sub.to_csv('sub_Weighted.csv',index=False)
```

![1621400376039](C:\Users\Ccy\AppData\Roaming\Typora\typora-user-images\1621400376039.png)



```
sub.head()
```

![1621400435940](C:\Users\Ccy\AppData\Roaming\Typora\typora-user-images\1621400435940.png)

